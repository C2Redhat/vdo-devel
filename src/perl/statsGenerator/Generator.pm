##
# Base class for statistics code generators.
#
# $Id$
##
package Generator;

use strict;
use warnings FATAL => qw(all);
use Carp;
use English qw(-no_match_vars);

use Permabit::Assertions qw(
  assertMinArgs
  assertMinMaxArgs
  assertNumArgs
);

use Statistic;

use base qw(Permabit::Propertied);

my $INDENTATION = "\t";
my $COPYRIGHT   = '%COPYRIGHT%';
my $LICENSE     = '%LICENSE%';
my $ATTENTION   = join(' ', ('ATTENTION!!!') x 5);
my $GENERATED
  = 'This file is machine generated by generateStatsCode.pl from:';
my $SOURCE      = '                SOURCE';
my $DO_NOT_EDIT = 'DO NOT EDIT THIS FILE BY HAND';
my $SPDX        = 'SPDX-License-Identifier: GPL-2.0-only';

##
# @paramList{new}
our %PROPERTIES
  = (
     # @ple The indentation stack
     indentation          => [],
     # @ple The current indentation string
     indentString         => '',
     # @ple The language this generator generates
     language             => undef,
     # @ple The current output file
     output               => undef,
     # @ple The attribute which is the output file name for this generator
     outputFileAttribute  => undef
    );
##

######################################################################
# Create a new code generator.
#
# @param pkg         The code generator package
# @param parameters  A hash of parameters for the generator
##
sub new {
  my ($pkg, %parameters) = assertMinArgs(1, @_);
  my $self = $pkg->SUPER::new(%parameters);
  if (!defined($self->{language})) {
    die("Generator does not specify a language");
  }

  $self->{outputFileAttribute} //= lc($self->{language}) . 'Header';
  return $self;
}

######################################################################
# Increment the indent level.
#
# @oparam indentString  If supplied, use this as the indent string for this
#                       level.
##
sub indent {
  my ($self, $indentString) = assertMinMaxArgs([$INDENTATION], 1, 2, @_);
  push(@{$self->{indentation}}, $indentString);
  $self->{indentString} = join('', @{$self->{indentation}});
}

######################################################################
# Add indentation that matches the length of the given string.
#
# @param matchLength  A string whose length becomes the next indent level
##
sub indentTo {
  my ($self, $matchLength) =  assertNumArgs(2, @_);

  my $indent = ' ' x length($matchLength);
  # Tabify.
  $indent =~ s/        /\t/g;
  $self->indent($indent);
}

######################################################################
# Decrement the indent level.
##
sub undent {
  my ($self) = assertNumArgs(1, @_);
  pop(@{$self->{indentation}});
  $self->{indentString} = join('', @{$self->{indentation}});
}

######################################################################
# Output indented text.
#
# @param text  The text to print.
##
sub emit {
  my ($self, $text) = assertNumArgs(2, @_);
  my $output = "$self->{indentString}$text";
  $output =~ s/\s*$/\n/;
  $self->{output}->print($output);
}

######################################################################
# Emit a blank line
#
# @oparam indent  If true, the blank line will be indented
##
sub blankLine {
  my ($self, $indent) = assertMinMaxArgs(1, 2, @_);
  if (defined($indent)) {
    $self->emit('');
  } else {
    $self->{output}->print("\n");
  }
}

######################################################################
# Convert the stat's name to lower case with underscore seperators.
#
# This function does its best to handle splitting up our stats in the
# correct way. The main issue is handling strings like "PBNCount" and
# "VIOs". For our stats, they should become "pbn_count" and "vios".
# This regex only handles the PBNCount style so VIOs would turn
# into vi_os. To fix this, we've added a C attribute override that
# will provide the correct spelling for vios and anything else down
# the road that isn't standard.
#
# @param statistic the statistic to convert
##
sub camelcaseToKernelStyle {
  my ($self, $statistic) =  assertNumArgs(2, @_);
  my $str = $statistic->getAttribute('C') // $statistic->{name};
  $str =~ s/(.)([A-Z][a-z]+)/$1_$2/g;
  $str =~ s/([a-z0-9])([A-Z])/$1_$2/g;
  $str = lc($str);

  return $str;
}

######################################################################
# Replace one or more strings in some text and then emit the result.
#
# @param text         The text
# @param toReplace    The string to replace
# @param replacement  The replacement for toReplace
# @param remainder    Additional toReplace, replacement pairs
##
sub replaceAndEmit {
  my ($self, $text, $toReplace, $replacement, @remainder)
    = assertMinArgs(4, @_);
  $text =~ s/$toReplace/$replacement/g;
  while (@remainder) {
    my $anotherToReplace = shift(@remainder);
    my $anotherReplacement = shift(@remainder);
    $text =~ s/$anotherToReplace/$anotherReplacement/g;
  }
  $self->emit($text);
}

######################################################################
# Check whether a statistic declares "no" for this generator's language.
#
# @param statistic  The statistic to check for a 'no' attribute
#
# @return true if this statistic should be skipped
##
sub shouldSkip {
  my ($self, $statistic) = assertNumArgs(2, @_);
  my $no = $statistic->getAttribute('no');
  return (defined($no) && ($no =~ /$self->{language}/));
}

######################################################################
# Generate code from the current statistic.
#
# @param statistic  The statistic to generate
##
sub generate {
  my ($self, $statistic) = assertNumArgs(2, @_);

  if ($self->shouldSkip($statistic)) {
    return;
  }

  # Call the appropriate generate method for the statistic.
  my $type      =  ref($statistic);
  $type         =~ s/.*:://;
  my $generator =  'generate' . ucfirst($type);
  $self->$generator($statistic);
}

######################################################################
# Generate code from a Statistic.
#
# @param statistic  The Statistic from which to generate
##
sub generateStatistic {
  my ($self, $statistic) = assertNumArgs(2, @_);

  # Make a new output file if required at this level
  my $outputFileName = $statistic->getAttribute($self->{outputFileAttribute});
  if (defined($outputFileName)) {
    $self->{output} = IO::File->new(">$outputFileName");
    if (!defined($self->{output})) {
      die("failed to open output file $outputFileName: $ERRNO\n");
    }

    $self->generateHeader($statistic);
  }

  # Generate all children.
  foreach my $child ($statistic->getChildren()) {
    $self->generate($child);
  }

  # Finish the output file if we created one at this level
  if (defined($outputFileName)) {
    $self->generateTrailer($statistic);
    delete($self->{output})->close();
  }
}

######################################################################
# Generate the copyright notice for an output file.
#
# @param statistic  The statistic being generated
##
sub generateCopyright {
  my ($self, $statistic) = assertNumArgs(2, @_);
  $self->emit($COPYRIGHT);
  $self->blankLine(1);
  $self->emit($LICENSE);
}

######################################################################
# Generate the attention notice for an output file.
#
# @param statistic  The statistic being generated
##
sub generateAttention {
  my ($self, $statistic) = assertNumArgs(2, @_);
  $self->emit($ATTENTION);
  $self->blankLine(1);
  $self->emit($GENERATED);
  $self->replaceAndEmit($SOURCE, 'SOURCE',
                        $statistic->getAttribute('sourceFile', 1));
  $self->blankLine(1);
  $self->emit($DO_NOT_EDIT);
}

######################################################################
# Generate the header of an output file.
#
# @param statistic  The Statistic being generated
##
sub generateHeader {
  my ($self, $statistic) = assertNumArgs(2, @_);
  $self->generateCopyright($statistic);
  $self->blankLine(1);
  $self->generateAttention($statistic);
}

######################################################################
# Generate the SPDX license identifier, with approprate comment
# delimiters for the file type.
#
##
sub generateSPDX {
  my ($self, $statistic) = assertNumArgs(2, @_);

  my $outputFileName = $statistic->getAttribute($self->{outputFileAttribute});
  my $identifier;
  if ($outputFileName =~ /\.c$/) {
    $identifier = "// $SPDX";
  } elsif ($outputFileName =~ /\.h$/) {
    $identifier = "/* $SPDX */";
  } elsif ($outputFileName =~ /\.pl$/) {
    $identifier = "# $SPDX";
  }
  if ($identifier) {
    $self->emit($identifier);
  }
}

######################################################################
# Print the statistics version as a constant in the language being
# generated.
#
# @param statistic  The statistic being generated
##
sub emitVersion {
  my ($self, $statistic) = assertNumArgs(2, @_);
  my $version            = $statistic->getAttribute('version', 1);
  if (!defined($version)) {
    return;
  }

  $self->generateEnum($version);
}

######################################################################
# Generate the trailer on an output file.
#
# @param statistic  The Statistic being generated
##
sub generateTrailer {
  my ($self, $statistic) = assertNumArgs(2, @_);
}

######################################################################
# Get the language specific type of a statistic.
#
# @param statistic  The Statistic
#
# @return The language specific type of the statistic.
##
sub getType {
  my ($self, $statistic) = assertNumArgs(2, @_);
  return $statistic->getType($self->{language});
}

######################################################################
# Generate a Command.
#
# @param command  The Command to generate.
##
sub generateCommand {
  my ($self, $command) = assertNumArgs(2, @_);

  # Language specific generators must override this method if they wish
  # to generate commands.
}

######################################################################
# Generate an Enum.
#
# @param enum  The Enum to generate.
##
sub generateEnum {
  my ($self, $enum) = assertNumArgs(2, @_);

  die("No Enum generator defined for $self->{language}\n");
}

######################################################################
# Generate a Struct.
#
# @param struct  The Struct to generate.
##
sub generateStruct {
  my ($self, $struct) = assertNumArgs(2, @_);

  die("No Struct generator defined for $self->{language}\n");
}

######################################################################
# Generate a Field
#
# @param field  The Field to generate.
##
sub generateField {
  my ($self, $field) = assertNumArgs(2, @_);

  die("No Field generator defined for $self->{language}\n");
}

######################################################################
# Quote a string if it is defined.
#
# @param string  The string to quote
#
# @return The quoted string or undef if the input was undef
##
sub quoteString {
  my ($self, $string) = assertNumArgs(2, @_);
  return (defined($string) ? qq|"$string"| : $string);
}

1;
